#version 460

#extension GL_KHR_vulkan_glsl : enable // Vulkan-specific syntax
#extension GL_GOOGLE_include_directive : enable // Include files
#extension GL_EXT_ray_tracing : enable // Raytracing
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_nonuniform_qualifier : enable


// fix resize
// Include structs and bindings
#ifndef includes
#define includes
#include "../../foray/src/shaders/rt_common/bindpoints.glsl"
#include "../../foray/src/shaders/common/camera.glsl"
#include "../../foray/src/shaders/rt_common/tlas.glsl"
#include "../../foray/src/shaders/rt_common/imageoutput.glsl"
#include "../../foray/src/shaders/common/lcrng.glsl"
#include "../../foray/src/shaders/common/noisetex.glsl"
#include "../../foray/src/shaders/shading/constants.glsl"
#include "common/materialbuffer.glsl"
#endif

float luminance(vec3 rgb)
{
    // Algorithm from Chapter 10 of Graphics Shaders.
    const vec3 W = vec3(0.2125, 0.7154, 0.0721);
    return dot(rgb, W);
}

layout(push_constant) uniform TracerConfigBlock
{
    /// @brief Per frame unique seed for random number generation
    uint RngSeed;
	uint DiscardPrevFrameReservoir;
}
TracerConfig;

layout(binding = 11,  set = 0) readonly uniform RestirConfiguration
{
    /// @brief Current frames projection matrix
    mat4   PrevFrameProjectionViewMatrix;
    vec4   CameraPos;
    uvec2  ScreenSize;
    uint   ReservoirSize;
    uint   Frame;
    uint   InitialLightSampleCount;
    uint   TemporalSampleCountMultiplier;
    float  SpatialPosThreshold;
    float  SpatialNormalThreshold;
    uint   SpatialNeighbors;
    float  SpatialRadius;
    uint   Flags;
	uint   NumTriLights;
}
RestirConfig;


//# i nclude "../structs.hpp"
struct TriLight
    {
        vec4  p1;
        vec4  p2;
        vec4  p3;
		vec4  normal;
        int  materialIndex;
		uint  reserved1;
		uint  reserved2;
		uint  reserved3;
    };
#include "restir/restirUtils.glsl"
#include "restir/brdf.glsl"

layout(set = 1, binding = 0) buffer Reservoirs{ Reservoir reservoirs[]; } reservoirs;
layout(set = 1, binding = 1) buffer PrevFrameReservoirs { Reservoir prevFrameReservoirs[]; } prevFrameReservoirs;

#define GBUFFER_ALBEDO 0
#define GBUFFER_NORMAL 1
#define GBUFFER_POS 2
#define GBUFFER_MOTION 3
#define GBUFFER_MATERIAL_INDEX 4
layout(set = 0, binding = 14) uniform sampler2D GBufferTextures[];

#define PREVIOUSFRAME_ALBEDO 0
#define PREVIOUSFRAME_NORMAL 1
#define PREVIOUSFRAME_POS 2
layout(set = 0, binding = 15) uniform sampler2D PreviousFrameImages[];
layout(std140, set = 0, binding = 16) buffer TriLights{ TriLight triLights[]; } triLights;

// Declare hitpayloads
#define HITPAYLOAD_OUT
#include "../../foray/src/shaders/rt_common/payload.glsl"

layout (location = 2) rayPayloadEXT bool isShadowed;

vec3 pickPointOnTriangle(float r1, float r2, vec3 p1, vec3 p2, vec3 p3) {

//	mat4 ProjMat      = Camera.ProjectionMatrix;
//    mat4 ViewMat      = Camera.ViewMatrix;
//
//	p1 = (ProjMat * ViewMat * vec4(p1, 1)).xyz;
//	p2 = (ProjMat * ViewMat * vec4(p2, 1)).xyz;
//	p3 = (ProjMat * ViewMat * vec4(p3, 1)).xyz;

	float sqrt_r1 = sqrt(r1);
	return (1.0 - sqrt_r1) * p1 + (sqrt_r1 * (1.0 - r2)) * p2 + (r2 * sqrt_r1) * p3;
}

bool testVisibility(vec3 p1, vec3 p2) {
	float tMin = 0.01f;
	vec3 dir = p2 - p1;

	isShadowed = true;

	float curTMax = length(dir);
	dir /= curTMax;

	traceRayEXT(
		MainTlas,            // acceleration structure
		gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT,       // rayFlags
		0xFF,           // cullMask
		0,              // sbtRecordOffset
		0,              // sbtRecordStride
		0,              // missIndex
		p1,             // ray origin
		tMin,           // ray min range
		dir,            // ray direction
		curTMax - 2.0f * tMin,           // ray max range
		2               // payload (location = 0)
	);

	return isShadowed;
}

// Offsets a ray origin slightly away from the surface to prevent self shadowing
void CorrectOrigin(inout vec3 origin, vec3 normal)
{
    origin += normal * 0.1;
} 

void main() 
{

	ivec2 t = ivec2(200,200);
	// calculate current pixel position
	uvec2 pixelCoord = gl_LaunchIDEXT.xy;

	vec3 cameraPos = Camera.InverseViewMatrix[3].xyz;

	// DEBUG: using printf calls only for pixel at X,Y=200
	bool activatePrintf = false;
	if(pixelCoord.x == 200 && pixelCoord.y == 200)
	{
		activatePrintf = false;
	}

	// =========================================================================================
	// random number generation
	ivec2 texSize = imageSize(NoiseSource);
	ivec2 texel = ivec2(pixelCoord.x % texSize.x, pixelCoord.y % texSize.y);

	uint left = TracerConfig.RngSeed;
	uint right = imageLoad(NoiseSource, texel).x;
	for (int i = 0; i < 4; i++)
	{
		uint temp = left & 0xFFFF | (right << 16);
		temp = lcgUint(temp) * lcgUint(temp);
		right += left;
		left += temp;
	}
	ChildPayload.Seed = left + right;
	uint randomSeed = left + right;

	// =========================================================================================
	// collect gbuffer information
	vec3 gbuf_albedo = texelFetch(GBufferTextures[GBUFFER_ALBEDO], ivec2(pixelCoord), 0).xyz;
	vec3 gbuf_pos = texelFetch(GBufferTextures[GBUFFER_POS], ivec2(pixelCoord), 0).xyz;
	vec3 gbuf_normal = texelFetch(GBufferTextures[GBUFFER_NORMAL], ivec2(pixelCoord), 0).xyz;
	int gbuf_materialIndex = floatBitsToInt(texelFetch(GBufferTextures[GBUFFER_MATERIAL_INDEX], ivec2(pixelCoord), 0).x);
	if(pixelCoord.x == t.x && pixelCoord.y == t.y)
	{
		MaterialBufferObject mat = GetMaterialOrFallback(gbuf_materialIndex);
		//debugPrintfEXT("%f \n", mat.RoughnessFactor);
	}

//	if(gbuf_pos.x == 0 && gbuf_pos.y == 0 && gbuf_pos.z == 0)
//	{
//		// invalid position => discard
//		imageStore(ImageOutput, ivec2(pixelCoord), vec4(0));
//		return;
//	}

	MaterialBufferObject surfaceMaterial = GetMaterialOrFallback(int(gbuf_materialIndex));
	float albedoLum = luminance(gbuf_albedo);

	// =========================================================================================
	// create reservoir with initial samples
	Reservoir res = newReservoir();
	for (int i = 0; i < RestirConfig.InitialLightSampleCount; ++i)
	{
		// 1. Chose a 
		// chose a triangle with importance sampling by light power
		//aliasTableSample(randFloat(rand), randFloat(rand), selected_idx, lightSampleProb);

		// probability for each light, sums to 1 bcs of the 32 initial samples.
		float lightSampleProb = 1.0f/32.0f;

		uint randomNr = lcgUint(randomSeed);
		uint selected_idx = randomNr % RestirConfig.NumTriLights;

		// pick a random point on the triangle light
		// debug: triangle index 11 always yields 0.

		TriLight light = triLights.triLights[selected_idx];
		vec3 lightSamplePos = pickPointOnTriangle(lcgFloat(randomSeed), lcgFloat(randomSeed), light.p1.xyz, light.p2.xyz, light.p3.xyz);

		// TODO: calculate luminance from material id
		// lightSampleLum = light.emission_luminance.w;
		MaterialBufferObject lightMaterial = GetMaterialOrFallback(light.materialIndex);
		float lightSampleLum = luminance(lightMaterial.EmissiveFactor);

		vec3 wi = normalize(gbuf_pos - lightSamplePos);
		vec3 normal = normalize(vec3(light.normal.xyz));

		// lights that don't face surface are discarded?
		float normalToLight = clamp(dot(wi, normal), 1e-4, 1);
		float triangleAreaSize = light.normal.w; // the bigger the triangle, the smaller the probability
		lightSampleProb *= normalToLight * triangleAreaSize; // the worse the normalToLight angle, the smaller the probability


		//debugPrintfEXT("normalToLightFactor %f, triangleAreaSize %f, lightSampleProb %f \n", normalToLight, triangleAreaSize,lightSampleProb);
		vec4 lightNormal = vec4(normal, 1.0f);

		// evaluate light emission, based on view angle and material brdf
		float pHat = evaluatePHat(
			gbuf_pos, lightSamplePos, cameraPos,
			gbuf_normal, lightNormal.xyz, lightNormal.w > 0.5f,
			albedoLum, lightSampleLum, surfaceMaterial.RoughnessFactor, surfaceMaterial.MetallicFactor
		);

		if(distance(gbuf_pos, lightSamplePos) < 1)
		{
			pHat = 0.0f;
		}

		 //pHat = 1.0f;

		addSampleToReservoir(res, lightSamplePos, lightNormal, lightSampleLum, selected_idx, pHat, lightSampleProb, randomSeed, false);
	}

	 // check if the RESERVOIR_SIZE selected samples are have visibility to surface point
		for (int i = 0; i < RESERVOIR_SIZE; i++) {
			vec3 lightDir = normalize(res.samples[i].position_emissionLum.xyz - gbuf_pos);
			vec3 origin = gbuf_pos;
			CorrectOrigin(origin, gbuf_normal);
			bool shadowed = testVisibility(origin, res.samples[i].position_emissionLum.xyz);
			//shadowed = testVisibility(worldPos, lightSamplePos2);
			//debugPrintfEXT(" shadowed = %d \n", shadowed);
			if (shadowed) { 
				res.samples[i].w = 0.0f;
				res.samples[i].sumWeights = 0.0f;
			}
		} 

	// =========================================================================================
	// use motion buffer for reprojection of the pixels
	// scale motion range from 0..1 to screen space
	vec2 screenSize = vec2(RestirConfig.ScreenSize);
	vec2 motion = texelFetch(GBufferTextures[GBUFFER_MOTION], ivec2(pixelCoord), 0).xy * screenSize;
	// + 0.5 to move from pixel center leads to more accurate reprojection
	//vec2 oldCoords = pixelCoord + motion + vec2(0.5f);
	vec2 oldCoords = pixelCoord + motion + vec2(0.5f);
	
	
	bool positionDiffValid = false;
	bool normalDiffValid = false;
	bool albedoDiffValid = false;
	if(
		all(greaterThanEqual(oldCoords.xy, vec2(-1.0f))) &&
		all(lessThanEqual(oldCoords.xy, screenSize))
	)
	{
		// compare world space position
		vec3 oldWorldPos = texelFetch(PreviousFrameImages[PREVIOUSFRAME_POS], ivec2(oldCoords), 0).xyz;
		vec3 positionDiff = gbuf_pos - oldWorldPos;
		const float maxPosDiff = 0.15f;
		if (dot(positionDiff,positionDiff) < maxPosDiff*maxPosDiff) {
			positionDiffValid = true;
		}

		// compare surface normal
		vec3 oldNormal = texelFetch(PreviousFrameImages[PREVIOUSFRAME_NORMAL], ivec2(oldCoords), 0).xyz;
		vec3 normalDiff = gbuf_normal - oldNormal;
		if (dot(normalDiff, normalDiff) < 0.05f) {
			normalDiffValid = true;
		}

		// compare albedo change
		vec3 oldAlbedo = texelFetch(PreviousFrameImages[PREVIOUSFRAME_ALBEDO], ivec2(oldCoords), 0).xyz;
		vec3 albedoDiff = gbuf_albedo - oldAlbedo;
		if (dot(albedoDiff, albedoDiff) < 0.05f) {
			albedoDiffValid = true;
		}
	}

	// =========================================================================================
	// TEMPORAL REUSE
	if(true)
	{
	bool validForTemporalReuse = positionDiffValid && normalDiffValid && albedoDiffValid;
	if(validForTemporalReuse)
	{
		uvec2 prevFragCoords = uvec2(oldCoords - vec2(0.5));
		Reservoir prevRes = prevFrameReservoirs.prevFrameReservoirs[prevFragCoords.y * RestirConfig.ScreenSize.x + prevFragCoords.x];

		// clamp the number of samples
		prevRes.numStreamSamples = min(
			prevRes.numStreamSamples, 1000
		);
		 
		// this is a reevluation of the light influence from previous samples.

		float pHat[RESERVOIR_SIZE];
		for (int i = 0; i < RESERVOIR_SIZE; ++i) {
			TriLight light = triLights.triLights[prevRes.samples[i].lightIndex];
			MaterialBufferObject material = GetMaterialOrFallback(light.materialIndex);
			float lightSampleLum = luminance(material.EmissiveFactor);

			 pHat[i] = evaluatePHat(
				gbuf_pos, prevRes.samples[i].position_emissionLum.xyz, cameraPos,
				gbuf_normal, prevRes.samples[i].normal.xyz, prevRes.samples[i].normal.w > 0.5f,
				albedoLum, lightSampleLum, surfaceMaterial.RoughnessFactor, surfaceMaterial.MetallicFactor
				);
				//pHat[i] = 1.0f;
			}

			combineReservoirs(res, prevRes, pHat, randomSeed, activatePrintf);
		}
	}
	
	  
	// =========================================================================================
	// SPATIAL REUSE
	//Reservoir spatialReservoir = newReservoir();
	if(true)
	{
		uint numNeighbours = RestirConfig.SpatialNeighbors;
		numNeighbours = 1;
		for(int i = 0; i < numNeighbours; i++)
		{
			ivec2 randNeighbor = ivec2(0, 0);
		
			float angle = lcgFloat(randomSeed) * 2.0 * PI;
			float spatialRadius = RestirConfig.SpatialRadius;
			spatialRadius = 2.0f;
			float radius = sqrt(lcgFloat(randomSeed)) * spatialRadius;

			ivec2 randNeighborOffset = ivec2(round(cos(angle) * radius), round(sin(angle) * radius));

			randNeighbor.x = randNeighborOffset.x + int(oldCoords.x);
			randNeighbor.y = randNeighborOffset.y + int(oldCoords.y);

			if(randNeighbor.x < 0 || randNeighbor.x > int(RestirConfig.ScreenSize.x) - 1 ||
				randNeighbor.y < 0 || randNeighbor.y > int(RestirConfig.ScreenSize.y) - 1 )
			{ 
				continue;
			}
			
//			ivec2 randNeighborOffset = ivec2(floor(cos(angle) * radius), floor(sin(angle) * radius));
//			randNeighbor.x = clamp(int(oldCoords.x) + randNeighborOffset.x, 0, int(RestirConfig.ScreenSize.x) - 1);
//			randNeighbor.y = clamp(int(oldCoords.y) + randNeighborOffset.y, 0, int(RestirConfig.ScreenSize.y) - 1);

			uint randIndex = randNeighbor.y * RestirConfig.ScreenSize.x + randNeighbor.x;
			if(activatePrintf)
			{
				debugPrintfEXT("reservoir random index %d, radius %f, angle %f, \n", randIndex, radius, angle);
			}

			// Discard over biased neighbors
			vec3 neighborPos = texelFetch(PreviousFrameImages[PREVIOUSFRAME_POS], ivec2(randNeighbor), 0).xyz;
			vec3 neighborNor = texelFetch(PreviousFrameImages[PREVIOUSFRAME_NORMAL], ivec2(randNeighbor), 0).xyz;

			vec3 posDiff = neighborPos - gbuf_pos;
			float spatialThreshold = RestirConfig.SpatialPosThreshold;
			spatialThreshold = 0.1;
			float posDiffMaxSquared = spatialThreshold * spatialThreshold;

			float spatialNormalThreshold = RestirConfig.SpatialNormalThreshold;
			spatialNormalThreshold = 20.0f;
			if (
				dot(posDiff, posDiff) > posDiffMaxSquared ||
				dot(neighborNor, gbuf_normal) < cos(radians(spatialNormalThreshold))
			) {
				continue;
			}

			Reservoir randRes = prevFrameReservoirs.prevFrameReservoirs[randIndex];

//			randRes.numStreamSamples = min(  
//				randRes.numStreamSamples,  100
//			);

			float newPHats[RESERVOIR_SIZE];
			for (int j = 0; j < RESERVOIR_SIZE; ++j) {
//				float newPHat = evaluatePHat(
//					worldPos, randRes.samples[j].position_emissionLum.xyz, uniforms.cameraPos.xyz,
//					normal, randRes.samples[j].normal.xyz, randRes.samples[j].normal.w > 0.5f,
//					albedoLum, randRes.samples[j].position_emissionLum.w, roughnessMetallic.x, roughnessMetallic.y);
			
				TriLight light = triLights.triLights[randRes.samples[j].lightIndex];
				MaterialBufferObject material = GetMaterialOrFallback(light.materialIndex);
				float lightSampleLum = luminance(material.EmissiveFactor);

				newPHats[i] = evaluatePHat(
					gbuf_pos, randRes.samples[j].position_emissionLum.xyz, cameraPos,
					gbuf_normal, randRes.samples[j].normal.xyz, randRes.samples[j].normal.w > 0.5f,
					albedoLum, lightSampleLum, surfaceMaterial.RoughnessFactor, surfaceMaterial.MetallicFactor
				);
				//newPHats[j] = 1.0f;
			}

			combineReservoirs(res, randRes, newPHats, randomSeed, activatePrintf);
		}

		

	}

	// =========================================================================================
	// update visibility
	bool shadowed = true;
	for (int i = 0; i < RESERVOIR_SIZE; i++) 
	{
		// visbility ray from visible world pos to selected light source 
		vec3 lightDir = normalize(res.samples[i].position_emissionLum.xyz - gbuf_pos);
		vec3 origin = gbuf_pos;
		CorrectOrigin(origin, gbuf_normal);
		
		shadowed = testVisibility(origin, res.samples[i].position_emissionLum.xyz);
		if (shadowed)
		{
			res.samples[i].w = 0.0f;
			res.samples[i].sumWeights = 0.0f;
			res.samples[i].pHat = 0.0f;
			//combineReservoirs(res, spatialReservoir, newPHats, randomSeed, activatePrintf);
		}
		else
		{

		}
	}


	// =========================================================================================
	// WRITE BACK RESERVOIRS
	uint reservoirIndex = pixelCoord.y * RestirConfig.ScreenSize.x + pixelCoord.x;
	reservoirs.reservoirs[reservoirIndex] = res;

	//debugPrintfEXT("Brightness pHat %f , number of samples %d \n", res.samples[0].pHat, res.numStreamSamples);
	vec4 finalColor;
	{

		// TODO: when adding first sample to reservoir, sample should always be added so light index cannot 
		// be invalid
		// evaluate light material
		uint lightIndex = res.samples[0].lightIndex;

		TriLight light = triLights.triLights[lightIndex];
		MaterialBufferObject material22 = GetMaterialOrFallback(light.materialIndex);
		
		// ok what the fuck is going on. :')
		//finalColor = vec4(gbuf_albedo * vec3(res.samples[0].pHat) + surfaceMaterial.EmissiveFactor, 1.0f);

		
		// surface is emissive
		if(dot(surfaceMaterial.EmissiveFactor,surfaceMaterial.EmissiveFactor) > 0)
		{
			// for emissive surfaces use surface albedo or material emissive factor
			finalColor = vec4( gbuf_albedo, 1.0f);
			if(dot(gbuf_albedo,gbuf_albedo) <= 0)
				finalColor = vec4( surfaceMaterial.EmissiveFactor, 1.0f);
		}
		else // surface is not emissive => light surface
		{
			finalColor = vec4( gbuf_albedo * vec3(res.samples[0].pHat) , 1.0f);
			finalColor *= 100; // increase lighting power
		}
		
		// no additional lighting on surfaces that are emissive -> that looks kinda bad.
		if(dot(surfaceMaterial.EmissiveFactor, surfaceMaterial.EmissiveFactor) <= 0)
			finalColor *=  vec4(material22.EmissiveFactor ,1);
	}

//	if(!positionDiffValid)
//	{
//		//imageStore(ImageOutput, ivec2(pixelCoord), vec4(1,0,0,1));
//	}
//	else
//	{
//		imageStore(ImageOutput, ivec2(pixelCoord), vec4(finalColor));
//	}
	imageStore(ImageOutput, ivec2(pixelCoord), vec4(finalColor));

	if(pixelCoord.x == t.x && pixelCoord.y == t.y)
	{
		debugPrintfEXT("%d mat Index %f roughness, %f metallic (%f,%f,%f) EmissiveFactor \n", gbuf_materialIndex, surfaceMaterial.RoughnessFactor, surfaceMaterial.MetallicFactor,
		surfaceMaterial.EmissiveFactor.x, surfaceMaterial.EmissiveFactor.y, surfaceMaterial.EmissiveFactor.z );
		imageStore(ImageOutput, t, vec4(1,0,1,1));
	}
//	else
//	{
//		if(!positionDiffValid)
//		{
//			imageStore(ImageOutput, ivec2(pixelCoord), vec4(0,1,0,1));
//		}
//		else
//			imageStore(ImageOutput, ivec2(pixelCoord), vec4(finalColor));
//	}

	// show tracked pixel
	

	// debug show discards
//	if(positionDiffValid && normalDiffValid && albedoDiffValid )
//	{} 
//	else
//	{
//		imageStore(ImageOutput, ivec2(pixelCoord), vec4(1,0,0,1));
//	}
}
